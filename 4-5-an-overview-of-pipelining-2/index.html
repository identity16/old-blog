
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>4.5 An Overview of Pipelining(2)</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=c71482df51">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130578466-1"></script>
    <script>
        var host = window.location.hostname;
        if(host !== "localhost")
        {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-130578466-1');
        }
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6003792608716119",
            enable_page_level_ads: true
        });
    </script>

    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="Identity16">
    <meta property="og:type" content="article">
    <meta property="og:title" content="4.5 An Overview of Pipelining(2)">
    <meta property="og:description" content="An Overview of Pipelining(2) Hazards   Hazard란 다음 Instruction을 바로 다음 사이클에서 실행할 수 없도록 하는 상황을 뜻한다. Hazard를 해결하지 못하면 작업을 하지 않는 사이클이 발생해 Pipeline이 느리게 동작한다. Hazard의 종류를 살펴보자. Structure Hazard : 사용하려는 자원이 이용 중인 경우 Data Hazard : 앞선 Instruction이 Read나 Write를 할 때까지 기다려야 하는 경우">
    <meta property="og:url" content="http://identity16.github.io/4-5-an-overview-of-pipelining-2/">
    <meta property="og:image" content="http://identity16.github.io/content/images/2019/01/133.jpg">
    <meta property="article:published_time" content="2018-12-11T13:35:00.000Z">
    <meta property="article:modified_time" content="2019-01-10T10:48:07.000Z">
    <meta property="article:tag" content="computer-architecture">
    
    <meta property="article:publisher" content="https://www.facebook.com/profile.php?id=100005042917362">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="4.5 An Overview of Pipelining(2)">
    <meta name="twitter:description" content="An Overview of Pipelining(2) Hazards   Hazard란 다음 Instruction을 바로 다음 사이클에서 실행할 수 없도록 하는 상황을 뜻한다. Hazard를 해결하지 못하면 작업을 하지 않는 사이클이 발생해 Pipeline이 느리게 동작한다. Hazard의 종류를 살펴보자. Structure Hazard : 사용하려는 자원이 이용 중인 경우 Data Hazard : 앞선 Instruction이 Read나 Write를 할 때까지 기다려야 하는 경우">
    <meta name="twitter:url" content="http://identity16.github.io/4-5-an-overview-of-pipelining-2/">
    <meta name="twitter:image" content="http://identity16.github.io/content/images/2019/01/133.jpg">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Wonjun Shin">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="computer-architecture">
    <meta property="og:image:width" content="2000">
    <meta property="og:image:height" content="1333">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Identity16",
        "logo": "http://identity16.github.io/content/images/2019/01/identity16-logo.png"
    },
    "author": {
        "@type": "Person",
        "name": "Wonjun Shin",
        "url": "http://identity16.github.io/author/wonjun/",
        "sameAs": [
            "https://identity16.github.io"
        ]
    },
    "headline": "4.5 An Overview of Pipelining(2)",
    "url": "http://identity16.github.io/4-5-an-overview-of-pipelining-2/",
    "datePublished": "2018-12-11T13:35:00.000Z",
    "dateModified": "2019-01-10T10:48:07.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://identity16.github.io/content/images/2019/01/133.jpg",
        "width": 2000,
        "height": 1333
    },
    "keywords": "computer-architecture",
    "description": "An Overview of Pipelining(2) Hazards   Hazard란 다음 Instruction을 바로 다음 사이클에서 실행할 수 없도록 하는 상황을 뜻한다. Hazard를 해결하지 못하면 작업을 하지 않는 사이클이 발생해 Pipeline이 느리게 동작한다. Hazard의 종류를 살펴보자. Structure Hazard : 사용하려는 자원이 이용 중인 경우 Data Hazard : 앞선 Instruction이 Read나 Write를 할 때까지 기다려야 하는 경우",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://identity16.github.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=c71482df51"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "7a8d29fdecb1"
});
</script>
    <meta name="generator" content="Ghost 2.9">
    <link rel="alternate" type="application/rss+xml" title="Identity16" href="../rss/index.html">

</head>
<body class="post-template tag-computer-architecture">

    <div class="site-wrapper">

        

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="../"><img src="../content/images/2019/01/identity16-logo.png" alt="Identity16"></a>
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="../">Home</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
                <a class="social-link social-link-fb" href="https://www.facebook.com/profile.php?id=100005042917362" title="Facebook" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
</a>
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/http://identity16.github.io/rss/" title="RSS" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-computer-architecture ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2018-12-11">11 December 2018</time>
                        <span class="date-divider">/</span> <a href="../tag/computer-architecture/">computer-architecture</a>
                </section>
                <h1 class="post-full-title">4.5 An Overview of Pipelining(2)</h1>
            </header>

            <figure class="post-full-image">
                <img src="../content/images/size/w2000/2019/01/133.jpg" alt="4.5 An Overview of Pipelining(2)">
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <h1 id="anoverviewofpipelining2">An Overview of Pipelining(2)</h1>
<h2 id="hazards">Hazards</h2>
<p>  Hazard란 다음 Instruction을 바로 다음 사이클에서 실행할 수 없도록 하는 상황을 뜻한다. Hazard를 해결하지 못하면 작업을 하지 않는 사이클이 발생해 Pipeline이 느리게 동작한다. Hazard의 종류를 살펴보자.</p>
<ul>
<li>Structure Hazard : 사용하려는 자원이 이용 중인 경우</li>
<li>Data Hazard : 앞선 Instruction이 Read나 Write를 할 때까지 기다려야 하는 경우</li>
<li>Control Hazard : 앞 Instruction에 의해 Control 동작이 결정되는 경우</li>
</ul>
<h3 id="structurehazard">Structure Hazard</h3>
<p> 여러 Instruction이 동시에 같은 리소스에 접근하는 경우이다. 메모리가 하나 뿐인 MIPS pipeline에서는, Load / Store가 메모리 데이터에 접근을 요청하면  Instruction Fetch 단계인 다른 Instruction은 Load / Store이 끝날 때까지 기다리고 있어야 한다. IF 단계인 Instruction은 한 사이클을 아무 작업도 하지 못하고 기다리는데, 이 때 Pipeline "Bubble"이 발생했다고 한다.</p>
<p>  이러한 Structure Hazard를 해결하기 위해서는 Instruction 메모리와 Data 메모리를 분리해야 한다. 아니면 Instruction / Data 캐시를 분리해도 된다.</p>
<h3 id="datahazard">Data Hazard</h3>
<p>  이전 Instruction의 결과를 현재 Instruction에서 사용하려고 할 때, 이전 Instruction의 WB가 끝날 때까지 기다린 다음 현재 Instruction의 ID를 수행해야 한다. 이 경우를 Data Hazard라 한다. 아래와 같은 상황을 예시로 들어보자.</p>
<pre><code class="language-assembly">add $s0, $t0, $t1
sub $t2, $s0, $t3
</code></pre>
<p>  여기를 보면 <code>add</code>의 R<sub>d</sub>인 <code>$s0</code>가 <code>sub</code>의 R<sub>s</sub>로 사용되었다. 우리가 아는 파이프라인에서는 아래와 같이 두 사이클을 쉬어야한다.</p>
<p><img src="../content/images/2019/01/computer-architecture-4-5-7.png" alt="computer-architecture-4-5-7"></p>
<h4 id="forwardingbypassing">Forwarding(Bypassing)</h4>
<p>  Data Hazard를 피하기 위한 방법인 Forwarding은 이전 Instruction의 WB 단계까지 기다리지 않고 레지스터에 저장될 값을 현재 Instruction의 EX의 입력값으로 끌어올 수 있도록 한다.</p>
<p><img src="../content/images/2019/01/computer-architecture-4-5-8.png" alt="computer-architecture-4-5-8"></p>
<p> 이렇게 하면 낭비되는 사이클 없이 바로 Instruction을 이어서 실행할 수 있다.</p>
<h4 id="loadusedatahazard">Load-Use Data Hazard</h4>
<p> 이번에는 EX 단계에서 계산되는 것이 아닌 메모리에서 가져오는 데이터로 인해 발생하는 Data Hazard에 대해 살펴보자. 이번에는 예시코드가 아까와는 다르다.</p>
<pre><code class="language-assembly">lw $s0, 20($t1)
sub $t2, $s0, $t3
</code></pre>
<p>   <code>$s0</code>에 들어갈 값은 EX에서 결정되던 이전 상황과는 달리 MEM에서 결정된다. Forwarding을 하더라도 <code>lw</code>의 MEM 단계 이후에 <code>sub</code>의 EX가 나와야 하기 때문에 아래 이미지와 같다.</p>
<p><img src="../content/images/2019/01/computer-architecture-4-5-9.png" alt="computer-architecture-4-5-9"></p>
<p> 여기서는 사이클 낭비를 완전히 없앨 수는 없고 1 사이클로 줄이는 데에서 그친다.</p>
<h4 id="codeschedulingtoavoidstalls">Code Scheduling to Avoid Stalls</h4>
<p>  Hazard가 발생하지 않도록 Instruction을 순서 재배치하라는 얘기이다. 자세한 설명은 일단 생략하겠다.</p>
<h3 id="controlhazard">Control Hazard</h3>
<p>  파이프라이닝을 할 때, 이전 Instruction이 Branch(ex - <code>beq</code>)이면 ID 단계가 지난 후에야 다음에 실행할 Instruction을 알 수 있다. 그렇게 되면 아래 이미지*(강의 교재 figure 4.31)*처럼 한 사이클의 대기(Stall)가 발생한다.( <code>beq</code> 의 EX 단계까지 기다리지 않는 이유는 <code>beq</code>의 ALU 연산과 다음 Instruction의 IF 까지 한 사이클 내에 실행할 수 있어서라고 합니다. 이 내용에 대해서는 확신이 없기 때문에 정확한 이유를 알고 계신 분은 알려주시면 감사하겠습니다.)</p>
<p><img src="../content/images/2019/01/computer-architecture-4-5-10.png" alt="computer-architecture-4-5-10"></p>
<p> 이를 개선하는 방법으로 Branch Prediction이 있다.</p>
<h4 id="branchprediction">Branch Prediction</h4>
<p>  더 많은 일을 수행하는 파이프라인에서는 브랜치 결과를 빨리 낼 수 없다. 그렇게 되면 지금처럼 한 사이클이 아니라 훨씬 더 많은 사이클 대기(Stall)가 발생한다. Stall을 조금이라도 줄이기 위해 브랜치의 결과를 예측하여 예측이 틀릴 때만 Stall이 발생하도록 하는 방식이 Branch Prediction이다.</p>
<p>  Branch Prediction의 동작은 다음 사이클에서 예측되는 Instruction을 미리 Fetch한 다음, 만약 예측이 맞았으면 계속 수행하고 틀렸다면 Fetch된 것은 무효화하고 다른 주소에 대해 IF 단계부터 다시 수행한다. 그렇게 하면 예측이 맞았을 때의 사이클 낭비는 없게 된다.</p>
<h4 id="morerealisticbranchprediction">More-Realistic Branch Prediction</h4>
<p>  Branch Prediction으로 예측이 맞았을 때의 Stall을 제거할 수 있다는 것을 알았으니, 이것을 더 효율적으로 만들기 위해서는 예측이 맞을 확률을 높일 필요가 있다. 어떻게 예측 확률을 높일 수 있을지 한 번 알아보자.</p>
<h5 id="staticbranchprediction">Static Branch Prediction</h5>
<p> 코드를 해석하여 문법의 특성에 맞게 예측한다. 그 예시로 반복문과 조건문(if)을 들 수 있다. 우선, 반복문은 반복이 수행되는 것이 더 확률이 높기 때문에 반복할 첫 Instruction의 주소로 예측한다. 다음으로 조건문에서의 branch는 조건이 맞았을 때를 예측하는 편이 더 확률이 높다고 보고 조건문의 첫 Instruction의 주소를 예측한다. 물론, 다른 이유로 다른 예측을 할 수도 있으므로 위 예시는 무조건적인 정답은 아니다.</p>
<h5 id="dynamicbranchprediction">Dynamic Branch Prediction</h5>
<p> 지금까지 브랜치가 동작한 기록을 바탕으로 앞으로 예상되는 값을 추정하는 방식이다. 하드웨어에서 기록을 측정한다.</p>
<h2 id="pipelinesummary">Pipeline Summary</h2>
<ul>
<li>파이프라이닝은 Throughput을 향상시킴으로서 성능을 향상하는 방법이다.
<ul>
<li>여러 Instruction을 병렬적으로 실행함</li>
<li>각각의 Instruction은 같은 실행시간을 가짐</li>
</ul>
</li>
<li>Hazard에 영향을 받는다.</li>
<li>Instruction Set 설계는 파이프라인 구현의 복잡도에 영향을 미친다.</li>
</ul>
<!--Image Credit(Freepik) -->
<a style="font-family:sans-serif; font-size: 15px; color: #26a8ed;
    text-decoration: none; box-shadow: none;" href="https://www.freepik.com/free-photos-vectors/background">Header Image created by Freepik</a>
                </div>
            </section>


            <footer class="post-full-footer">

                    
<section class="author-card">
        <span class="avatar-wrapper"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</span>
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/wonjun/">Wonjun Shin</a></h4>
            <p>Read <a href="../author/wonjun/">more posts</a> by this author.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/wonjun/">Read More</a>
</div>


            </footer>

            <section class="post-full-comments">
                <div id="disqus_thread"></div>
                <script>
                    var disqus_config = function () {
                        this.page.url = "http://identity16.github.io/4-5-an-overview-of-pipelining-2/";
                        this.page.identifier = "ghost-5c35f9bf2d91b6c5113154b5"
                    };
                    (function() {
                        var d = document, s = d.createElement('script');
                        s.src = 'https://identity16.disqus.com/embed.js';
                        s.setAttribute('data-timestamp', + new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
            </section>

        </article>
    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(../content/images/size/w600/2019/01/computer-architecture-cover-1.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— Identity16 —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/computer-architecture/">computer-architecture</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../5-3-the-basics-of-caches/">5.3 The Basics of Caches</a></li>
                            <li><a href="../5-2-memory-technologies/">5.2 Memory Technologies</a></li>
                            <li><a href="../5-1-introduction/">5.1 Introduction</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/computer-architecture/">See all 18 posts →</a>
                    </footer>
                </article>

                <article class="post-card post tag-computer-architecture ">

    <a class="post-card-image-link" href="../4-6-pipelined-datapath-and-control/">
        <img class="post-card-image" src="../content/images/size/w600/2019/01/water-pipe-51758_1280.jpg" alt="4.6 Pipelined Datapath and Control">
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../4-6-pipelined-datapath-and-control/">

            <header class="post-card-header">
                    <span class="post-card-tags">computer-architecture</span>
                <h2 class="post-card-title">4.6 Pipelined Datapath and Control</h2>
            </header>

            <section class="post-card-excerpt">
                <p>Pipelined Datapath and Control   여기서는 4.4장에서 완성했던 기존의 Single-Cycle Datapath를 Pipelined Datapath로 바꾸는 과정을 살펴볼 예정이다. 우선 회로를 아래 다섯 단계로 나누어 표시해보자. IF(Instruction Fetch) ID(Instruction Decode, Register File Read)</p>
            </section>

        </a>

        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        Wonjun Shin
                    </div>

                        <a href="../author/wonjun/" class="static-avatar author-profile-image"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</a>
                </li>
            </ul>

            <span class="reading-time">5 min read</span>

        </footer>

    </div>

</article>

                <article class="post-card post tag-computer-architecture ">

    <a class="post-card-image-link" href="../4-5-an-overview-of-pipelining-1/">
        <img class="post-card-image" src="../content/images/size/w600/2019/01/771654.jpg" alt="4.5 An Overview of Pipelining(1)">
    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../4-5-an-overview-of-pipelining-1/">

            <header class="post-card-header">
                    <span class="post-card-tags">computer-architecture</span>
                <h2 class="post-card-title">4.5 An Overview of Pipelining(1)</h2>
            </header>

            <section class="post-card-excerpt">
                <p>An Overview of Pipelining(1)   앞서 만든 프로세서 회로는 실제로는 거의 사용되지 않는다. 4.3의 마지막 단락은 다음과 같았다.   PC는 State Element이고, 나머지는 Combinational Element이기 때문에 전체 회로를 도는 데에는 1 Clock이 소요(</p>
            </section>

        </a>

        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        Wonjun Shin
                    </div>

                        <a href="../author/wonjun/" class="static-avatar author-profile-image"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"></path></g></svg>
</a>
                </li>
            </ul>

            <span class="reading-time">7 min read</span>

        </footer>

    </div>

</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="../">
                <img src="../content/images/size/w30/2019/01/identity16-favicon.png" alt="Identity16 icon">
            <span>Identity16</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">4.5 An Overview of Pipelining(2)</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=4.5%20An%20Overview%20of%20Pipelining(2)&amp;url=http://identity16.github.io/4-5-an-overview-of-pipelining-2/" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=http://identity16.github.io/4-5-an-overview-of-pipelining-2/" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>




        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="../">Identity16</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="../">Latest Posts</a>
                    <a href="https://www.facebook.com/profile.php?id=100005042917362" target="_blank" rel="noopener">Facebook</a>
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script>
        var images = document.querySelectorAll('.kg-gallery-image img');
        images.forEach(function (image) {
            var container = image.closest('.kg-gallery-image');
            var width = image.attributes.width.value;
            var height = image.attributes.height.value;
            var ratio = width / height;
            container.style.flex = ratio + ' 1 0%';
        })
    </script>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/built/jquery.fitvids.js?v=c71482df51"></script>


    <script type="text/javascript" async src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [["$", "$"], ["\\(", "\\)"]],
            processEscapes: true
        }
    });
</script>
<script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    

</body>
